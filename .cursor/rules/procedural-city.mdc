---
alwaysApply: true
---
# Procedural Futuristic City Engine

This is a Blade Runner-inspired procedural city generator built with C++20 and Vulkan. It creates a dystopian futuristic cityscape with procedural building generation, atmospheric rendering, volumetric lighting, and neon glow effects.

## Technology Stack

- **Language**: C++20 (CMAKE_CXX_STANDARD 20, required)
- **Graphics API**: Vulkan (direct Vulkan API usage, no wrapper libraries)
- **Window Management**: GLFW 3.4 (via FetchContent)
- **Math Library**: GLM 1.0.1 (via FetchContent)
- **Build System**: CMake 3.20+
- **Shaders**: GLSL compiled to SPIR-V using `glslc` (Vulkan Shader Compiler)
- **Platform**: macOS (MoltenVK support), Windows/Linux compatible

## Project Structure

### Core Components

- **Engine** (`src/Engine.cpp/hpp`): Main engine loop, window management via GLFW, input handling, coordinates renderer lifecycle
- **Renderer** (`src/Renderer.cpp/hpp`): Main rendering system, orchestrates all Vulkan rendering operations
- **RendererVulkanCore** (`src/RendererVulkanCore.cpp`): Vulkan instance, device, and surface creation
- **RendererSwapchain** (`src/RendererSwapchain.cpp`): Swapchain creation and management
- **RendererPipelines** (`src/RendererPipelines.cpp`): Graphics pipeline creation (city and neon pipelines)
- **RendererCamera** (`src/RendererCamera.cpp`): Camera controls and view/projection matrices
- **CityGenerator** (`src/CityGenerator.cpp/hpp`): Procedural city generation with buildings, branches, and neon lights
- **VulkanUtils** (`src/VulkanUtils.cpp/hpp`): Utility functions for Vulkan operations
- **main.cpp**: Entry point, initializes Engine and runs main loop

### Shaders

- Shaders live in `shaders/` directory (GLSL source: `.vert`, `.frag`)
- Compiled to SPIR-V (`.spv`) in `build/shaders/` via CMake custom command
- Uses `glslc` from Vulkan SDK for compilation
- Hot reloading: Engine supports runtime shader reloading via file watching (press `R` to toggle)
- Key shaders:
  - `city.vert/frag`: Main building rendering with fog, volumetric lighting, texture support
  - `neon.vert/frag`: Neon light rendering with bloom effects
  - `postprocess.frag`: Post-processing effects (HDR, bloom, vignette, grain)
  - `sun.vert/frag`: Sky light rendering
  - `hdr.frag`: HDR tone mapping
  - `bloom.frag`: Bloom extraction and blur

### Textures

Textures stored in:
- `textures/buildings/`: Building facade textures
- `textures/neon/`: Neon sign textures
- `textures/windows/`: Window/detail textures

Loaded via CoreGraphics/ImageIO on macOS or stb_image on other platforms.

## Code Organization

### Namespace

- All engine code uses `namespace pcengine`
- Vulkan handles use `Vk` prefix (standard Vulkan naming)

### Key Data Structures

- **Building**: Contains position, size, color, vector of BuildingPart (trunk + branches), neon lights, height variation
- **BuildingPart**: Position, size, color, detail level for recursive generation
- **NeonLight**: Position, color, intensity, radius
- **UniformBufferObject**: Model/view/proj matrices, camera pos, time, fog params, lighting
- **PostProcessingUBO**: Exposure, bloom, vignette, grain, color grading params

### Rendering Features

- Atmospheric fog with volumetric lighting
- Post-processing pipeline: HDR rendering, bloom, vignette, film grain
- Shadow mapping infrastructure (resources created, can be extended)
- Multiple rendering pipelines: city buildings, neon lights, post-processing
- Texture arrays for building/neon variety

## Build System

### CMake Configuration

- Vulkan SDK detection via `find_package(Vulkan)` or `VULKAN_SDK` environment variable
- macOS: Requires MoltenVK portability extensions (`VK_KHR_portability_enumeration`, `VK_KHR_portability_subset`)
- Shader compilation integrated as custom target `compile_shaders`
- All shaders compiled with `-O` (optimization) flag
- Platform-specific linking: Cocoa, IOKit, CoreVideo, CoreGraphics, ImageIO on macOS

### Build Commands

```bash
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release
cmake --build build -j
./build/procedural_city
```

Or use `./run.sh` for convenience (supports `clean`, `rebuild` flags).

## Development Guidelines

### Vulkan Best Practices

- Always check return values of Vulkan API calls (`VK_SUCCESS`, etc.)
- Use proper memory barriers for resource access
- Clean up resources in reverse order of creation (shutdown sequence matters)
- Use descriptor sets for uniform buffers, textures, samplers
- Command buffers allocated from command pool, recorded each frame
- Synchronization via semaphores (imageAvailableSemaphore, renderFinishedSemaphore) and fences

### Shader Development

- Write GLSL shaders, CMake compiles to SPIR-V automatically
- Shaders loaded from `PC_ENGINE_SHADER_DIR` (build/shaders at runtime)
- Hot reloading watches shader source files for changes
- Uniform buffer objects must match std140 alignment rules
- Use descriptor set layouts matching shader bindings

### City Generation

- CityGenerator uses seeded RNG (`std::mt19937`) for deterministic generation
- Grid-based placement with configurable density
- Recursive building branch generation with detail levels
- Height distribution uses exponential distribution
- Neon lights placed randomly on building facades

### Memory Management

- Use RAII where possible
- Vulkan resources (buffers, images) paired with device memory allocations
- Use `BufferWithMemory` helper struct for buffer+memory pairs
- Texture images loaded into staging buffer, then copied to device-local memory

## Platform Considerations

### macOS (MoltenVK)

- MoltenVK is Vulkan on Metal wrapper
- Portability extensions required
- Vulkan library located at `$VULKAN_SDK/lib` or `$VULKAN_SDK/macOS/lib`
- `glslc` at `$VULKAN_SDK/macOS/bin/glslc` or `$VULKAN_SDK/bin/glslc`
- Uses CoreGraphics/ImageIO for PNG loading (no stb_image dependency)

### Cross-Platform

- GLFW handles platform-specific window creation
- Vulkan surface created via `glfwCreateWindowSurface`
- Swapchain images acquired and presented per-frame
- Depth buffer uses `VK_FORMAT_D32_SFLOAT` or `VK_FORMAT_D24_UNORM_S8_UINT`

## Feature Implementation Status

- ✅ Procedural city generation with varied building heights
- ✅ Atmospheric fog with volumetric lighting
- ✅ Neon lighting with bloom effects
- ✅ Post-processing pipeline (HDR, bloom, vignette, grain)
- ✅ Hot reloadable shaders
- ✅ Texture support (buildings, neon, windows)
- ✅ Shadow map resources (infrastructure ready)
- ✅ Multiple rendering passes
- ⚠️ Camera is cinematic/slow-moving (not free-flight yet)

## Code Style Notes

- C++20 standard required
- No exceptions thrown in critical paths (return bool for error handling)
- Modern C++ features: `std::unique_ptr`, `std::vector`, `std::chrono`
- RAII for resource management
- Forward declarations used where possible
- Header guards: `#pragma once`