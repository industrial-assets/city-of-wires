#version 450

// Anamorphic bloom for volumetric scattering buffer
// Applies directional blur (horizontal and vertical passes) to create anamorphic lens flare effect

layout(local_size_x = 8, local_size_y = 8) in;

// Set 0: Constants (uniform buffer)
layout(set = 0, binding = 0) uniform Constants {
    mat4 view;
    mat4 proj;
    mat4 invView;
    mat4 invProj;
    mat4 viewProj;
    mat4 invViewProj;
    mat4 prevViewProj;
    mat4 invPrevViewProj;
    vec4 cameraPos;
    vec4 prevCameraPos;
    vec4 lightDir;
    vec4 fogColorSigma;
    vec4 params;
    vec4 jitterFrameTime;
} uConstants;

// Set 1: Images
layout(set = 1, binding = 0, rgba16f) uniform readonly image2D scatteringInput;
layout(set = 1, binding = 1, rgba16f) uniform writeonly image2D bloomOutput;

// Push constants for bloom parameters
layout(push_constant) uniform PushConstants {
    ivec4 dims;              // xy = output dimensions, z = pass direction (0=horiz, 1=vert), w = unused
    vec4 scalars0;           // x = threshold, y = intensity, z = blur radius, w = aspect ratio
    vec4 scalars1;           // x = sample count (float), y-w = unused
} push;

// Simple threshold function with smooth falloff
float brightnessMask(vec3 color, float threshold) {
    float luma = dot(color, vec3(0.2126, 0.7152, 0.0722));
    return smoothstep(threshold * 0.8, threshold * 1.2, luma);
}

void main() {
    ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 outputSize = push.dims.xy;
    
    if (pixelCoord.x >= outputSize.x || pixelCoord.y >= outputSize.y) {
        return;
    }
    
    // Determine blur direction
    int passDirection = push.dims.z; // 0 = horizontal, 1 = vertical
    vec2 blurDirection = (passDirection == 0) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
    
    // Apply aspect ratio correction to horizontal pass for anamorphic effect
    if (passDirection == 0) {
        blurDirection.x *= push.scalars0.w; // Aspect ratio stretch
    }
    
    float threshold = push.scalars0.x;
    float intensity = push.scalars0.y;
    float blurRadius = push.scalars0.z;
    int sampleCount = int(push.scalars1.x);
    
    // Read center pixel from input
    vec4 centerColor = imageLoad(scatteringInput, pixelCoord);
    
    // Apply brightness threshold
    float centerMask = brightnessMask(centerColor.rgb, threshold);
    
    // Accumulate samples along blur direction
    vec4 blurredColor = vec4(0.0);
    float totalWeight = 0.0;
    
    // Gaussian-like weights
    for (int i = -sampleCount; i <= sampleCount; ++i) {
        vec2 offset = blurDirection * float(i) * blurRadius;
        ivec2 sampleCoord = pixelCoord + ivec2(offset);
        
        // Clamp to image bounds
        sampleCoord = clamp(sampleCoord, ivec2(0), outputSize - ivec2(1));
        
        // Read sample
        vec4 sampleColor = imageLoad(scatteringInput, sampleCoord);
        
        // Weight based on distance (Gaussian-like falloff)
        float t = float(i) / float(sampleCount);
        float weight = exp(-3.0 * t * t);
        
        // Apply brightness masking to each sample
        float sampleMask = brightnessMask(sampleColor.rgb, threshold);
        
        blurredColor += sampleColor * weight * sampleMask;
        totalWeight += weight * sampleMask;
    }
    
    // Normalize and apply intensity
    if (totalWeight > 0.001) {
        blurredColor /= totalWeight;
        blurredColor *= intensity;
    }
    
    // Write output
    imageStore(bloomOutput, pixelCoord, blurredColor);
}

